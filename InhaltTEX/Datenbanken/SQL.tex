\subsection{SQL}
\label{sec:SQL}

Alle SQL-Komponenten für Abfragen siehe \referenz{sec:Datenbanken}.

\subsubsection{Projektion vs. Selektion}
\label{sec:ProjektionSelektion}

Quelle: Tino Hempel \cite{projektionSelektion}

\paragraph{Selektion} Bei der Selektion werden \hl{Zeilen aus einer Tabelle} ausgewählt, die bestimmten Eigenschaften genügen.

Aus der Tabelle Schüler sollen alle Zeilen selektiert werden, in denen der Name "Müller" steht. 
Die Selektion hat also die Form: $S_{Name} = _{'Mueller'}(Schueler)$

\vspace{1em}

\begin{minipage}{.45\textwidth}
	\begin{center}
		Schüler \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{|c|l|l|}
			\hline
			\rowcolor{tableLightGray}\underline{SNr} & Vorname & Name \\
			\hline
			4711 & Paul & Müller \\
			\hline
			0815 & Erich & Schmidt \\
			\hline
			7472 & Sven & Lehmann \\
			\hline
			1234 & Olaf & Müller \\
			\hline
			2313 & Jürgen & Paulsen \\
			\hline
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
	\begin{center}
		$S_{Name} = _{'Mueller'}(Schueler)$ \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{|c|l|l|}
			\hline
			\rowcolor{tableLightGray}\underline{SNr} & Vorname & Name \\
			\hline
			12 & Paul & Müller \\
			\hline
			308 & Olaf & Müller \\
			\hline
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}

\paragraph{Projektion} Bei der Projektion werden \hl{Spalten aus einer Tabelle} ausgewählt, die bestimmten Eigenschaften genügen.

Aus der Tabelle Schüler sollen alle Spalten mit dem Attribut 'Name' projiziert werden. 
Die Projektion hat also die Form: $P_{Name}(Schueler)$

\vspace{1em}

\begin{minipage}{.45\textwidth}
	\begin{center}
		Schüler \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{|c|l|l|}
			\hline
			\rowcolor{tableLightGray}\underline{SNr} & Vorname & Name \\
			\hline
			4711 & Paul & Müller \\
			\hline
			0815 & Erich & Schmidt \\
			\hline
			7472 & Sven & Lehmann \\
			\hline
			1234 & Olaf & Müller \\
			\hline
			2313 & Jürgen & Paulsen \\
			\hline
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
	\begin{center}
		$P_{Name}(Schueler)$ \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{|l|}
			\hline
			\rowcolor{tableLightGray} Name \\
			\hline
			Müller \\
			\hline
			Schmidt \\
			\hline
			Lehmann \\
			\hline
			Müller \\
			\hline
			Paulsen \\
			\hline
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}


\subsubsection{DDL, DML \& DCL}
\label{sec:DDLDMLDCL}

Quelle: GeeksforGeeks \cite{DDLDMLDCL}

\begin{enumerate}
	\item DDL - Data Definition Language
	\item DML - Data Manipulation Language
	\item DQL - Data Query Language
	\item DCL - Data Control Language
\end{enumerate}

\begin{center}
	\begin{tikzpicture}[
	item/.style={rectangle,draw,fill=blue!30, inner sep = 10},
	subitem/.style={rectangle,draw,fill=blue!20, inner sep = 8},
	grandchild/.style={grow=down,xshift=1em,anchor=west,
		edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}},
	first/.style={level distance=6ex},
	second/.style={level distance=12ex},
	third/.style={level distance=18ex},
	forth/.style={level distance=24ex},
	level 1/.style={sibling distance=10em}]
	% Parents
	\coordinate
	node[item,anchor=east]{SQL Commands}
	child[grow=down,level distance=2.5ex]
	[edge from parent fork down]
	% Children and grandchildren
	child{node[item] {DDL}
		child[grandchild,first] {node[subitem]{CREATE}}
		child[grandchild,second] {node[subitem]{DROP}}
		child[grandchild,third] {node[subitem] {ALTER}}
		child[grandchild, forth] {node[subitem] {TRUNCATE}}}
	child{node[item] {DML}
		child[grandchild,first] {node[subitem]{INSERT}}
		child[grandchild,second] {node[subitem]{UPDATE}}
		child[grandchild,third] {node[subitem]{DELETE}}}
	child {node[item]{DQL}
		child[grandchild,first] {node[subitem]{SELECT}}}
	child {node[item]{DCL}
		child[grandchild,first] {node[subitem]{GRANT}}
		child[grandchild,second] {node[subitem]{REVOKE}}};
\end{tikzpicture}
\end{center}

\subsubsection{CRUD}
\label{sec:CRUD}

Quelle: sqlshack.com \cite{crud}

\paragraph{C} refers to CREATE aka add, insert. In this operation, it is expected to insert a new record using the SQL insert statement. SQL uses \hl{INSERT INTO} statement to create new records within the table.

\begin{lstlisting}[language=SQL]
	INSERT INTO <tablename> (column1,column2,...) 
	VALUES(value1,value2,...),( value1,value2,...), (value1,value2,...)...
\end{lstlisting}

\begin{lstlisting}[language=SQL]
	INSERT INTO dbo.Demo
	(id, name)
	VALUES
	(2, 'Jayaram'),
	(3, 'Pravitha');
\end{lstlisting}

\paragraph{R} refers to \hl{SELECT} (data retrieval) operation. The word ‘read’ retrieves data or record-set from a listed table(s). SQL uses the SELECT command to retrieve the data.

\begin{lstlisting}[language=SQL]
	SELECT * FROM <TableName>;
\end{lstlisting}

\paragraph{U} refers to Update operation. Using the \hl{Update} keyword, SQL brings a change to an existing record(s) of the table. When performing an update, you’ll need to define the target table and the columns that need to update along with the associated values, and you may also need to know which rows need to be updated. In general, you want to limit the number of rows in order to avoid lock escalation and concurrency issues.

\begin{lstlisting}[language=SQL]
	UPDATE <TableName>
	SET Column1=Value1, Column2=Value2,...
	WHERE <Expression>
\end{lstlisting}

\paragraph{D} refers to removing a record from a table. SQL uses the SQL \hl{DELETE} command to delete the record(s) from the table.

\begin{lstlisting}[language=SQL]
	DELETE FROM <TableName>
	WHERE <Expression>
\end{lstlisting}

\subsubsection{Subqueries}
\label{sec:Subquery}



\subsubsection{Aggregatfunktionen}
\label{sec:Aggregatfunktionen}

\subsubsection{Mengenoperationen (Schnitt-, Vereinigungs- und Differenzmenge)}
\label{sec:Mengenoperationen}

Quelle: Glossar hs-augsburg \cite{mengenoperationHsaugsburg}

Mengenoperatoren \hl{verbinden zwei Abfragen zu einem Resultat}.

Beispieltabelle: \\

\begin{minipage}{0.45\textwidth}
	\begin{center}
		Tabelle student \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{l l l}
			\rowcolor{tableLightGray}matrikel\_nr & name & vorlesung \\
			\hline
			911574 & Meier & Java \\
			676676 & Schulz & Datenbanken
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
	\begin{center}
		Tabelle lehrender \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{l l l}
			\rowcolor{tableLightGray}matrikel\_nr & name & vorlesung \\
			\hline
			878999 & Kowa & Datenbanken \\
			665544 & Müller & XML
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}


\paragraph{UNION} bildet die Vereinigung zweier Relationen indem \hl{Zeilen der ersten Menge oder des ersten Operanden mit allen Zeilen der zweiten Menge} zusammengefasst werden. Zeilen, die in der Ergebnismenge zweimal vorkommen, werden zu einer einzigen Zeile zusammengefasst. Die Datentypen der Spalten müssen kompatibel sein, d.h. es muss entweder ein impliziter Cast (z.B. int auf double) möglich sein, oder wenn dies nicht möglich ist, muß ein expliziter Cast erfolgen. - dies bezieht sich auch auf die Anordnung der Spalten in der Abfrage.

\begin{lstlisting}[language=SQL]
	SELECT name  FROM student
	UNION
	SELECT name FROM lehrender
\end{lstlisting}

Ergebnis:\\

{
\bgroup
\setlength{\tabcolsep}{1em}
\def\arraystretch{1.5}
\begin{tabular}{l}
	\rowcolor{tableLightGray}name \\
	\hline
	Meier \\
	Schulz \\
	Kowa \\
	Müller
\end{tabular}
\egroup
}

\paragraph{UNION ALL} vereinigt alle Zeilen der ersten Menge oder des ersten Operanden mit allen Zeilen der zweiten Menge. Im Unterschied zu UNION werden auch die Duplikate ausgegeben.

\paragraph{INTERSECT} überprüft die \hl{Zeilen der beiden Eingangsmengen und gibt nur jene Zeilen aus, die in beiden Eingangsmengen vorkommen}. Die Durchschnittsmenge wird aus den zwei Relationen gebildete. Auch hier werden vor dem Erstellen der Ergebnismenge die redundanten Zeilen ausgeschaltet.

\begin{lstlisting}[language=SQL]
	SELECT vorlesung FROM student
	INTERSECT
	SELECT vorlesung FROM lehrender
\end{lstlisting}

Ergebnis:\\

{
\bgroup
\setlength{\tabcolsep}{1em}
\def\arraystretch{1.5}
\begin{tabular}{l}
	\rowcolor{tableLightGray}vorlesung \\
	\hline
	Datenbanken
\end{tabular}
\egroup
}

\paragraph{MINUS} gibt die Zeilen aus, \hl{die in der ersten Menge, NICHT aber in der zweiten Menge} enthalten sind. Zeilen, die in der ersten Menge zweimal vorkommen, werden auf Redundanz überprüft und komprimiert, bevor der Vergleich mit der zweiten Menge beginnt.

\begin{lstlisting}[language=SQL]
	SELECT vorlesung FROM student
	MINUS
	SELECT vorlesung FROM lehrender
\end{lstlisting}

Ergebnis:\\

{
	\bgroup
	\setlength{\tabcolsep}{1em}
	\def\arraystretch{1.5}
	\begin{tabular}{l}
		\rowcolor{tableLightGray}vorlesung \\
		\hline
		Java
	\end{tabular}
	\egroup
}

\subsubsection{SQL Injection}
\label{sec:SQLInjection}

Quelle: kaspersky \cite{sqlInjectionKaspersky}

Eine SQL-Injection, manchmal abgekürzt als SQLi, ist eine Art von Sicherheitslücke, bei der ein Angreifer einen Teil des SQL-Codes verwendet, \hl{um eine Datenbank zu manipulieren und Zugriff auf potenziell wertvolle Informationen zu erhalten}. Dies ist eine der häufigsten und bedrohlichsten Angriffsarten, da sie potenziell gegen jede Webanwendung oder Webseite eingesetzt werden kann, die eine SQL-basierte Datenbank verwendet (was bei den meisten der Fall ist).


