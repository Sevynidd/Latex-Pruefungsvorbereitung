\subsection{SQL}
\label{sec:SQL}

Alle SQL-Komponenten für Abfragen siehe \referenz{sec:Datenbanken}.

\subsubsection{Projektion vs. Selektion}
\label{sec:ProjektionSelektion}

Quelle: Tino Hempel \cite{projektionSelektion}

\paragraph{Selektion} Bei der Selektion werden \hl{Zeilen aus einer Tabelle} ausgewählt, die bestimmten Eigenschaften genügen.

Aus der Tabelle Schüler sollen alle Zeilen selektiert werden, in denen der Name "Müller" steht. 
Die Selektion hat also die Form: $S_{Name} = _{'Mueller'}(Schueler)$

\vspace{1em}

\begin{minipage}{.45\textwidth}
	\begin{center}
		Schüler \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{|c|l|l|}
			\hline
			\rowcolor{tableLightGray}\underline{SNr} & Vorname & Name \\
			\hline
			4711 & Paul & Müller \\
			\hline
			0815 & Erich & Schmidt \\
			\hline
			7472 & Sven & Lehmann \\
			\hline
			1234 & Olaf & Müller \\
			\hline
			2313 & Jürgen & Paulsen \\
			\hline
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
	\begin{center}
		$S_{Name} = _{'Mueller'}(Schueler)$ \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{|c|l|l|}
			\hline
			\rowcolor{tableLightGray}\underline{SNr} & Vorname & Name \\
			\hline
			12 & Paul & Müller \\
			\hline
			308 & Olaf & Müller \\
			\hline
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}

\paragraph{Projektion} Bei der Projektion werden \hl{Spalten aus einer Tabelle} ausgewählt, die bestimmten Eigenschaften genügen.

Aus der Tabelle Schüler sollen alle Spalten mit dem Attribut 'Name' projiziert werden. 
Die Projektion hat also die Form: $P_{Name}(Schueler)$

\vspace{1em}

\begin{minipage}{.45\textwidth}
	\begin{center}
		Schüler \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{|c|l|l|}
			\hline
			\rowcolor{tableLightGray}\underline{SNr} & Vorname & Name \\
			\hline
			4711 & Paul & Müller \\
			\hline
			0815 & Erich & Schmidt \\
			\hline
			7472 & Sven & Lehmann \\
			\hline
			1234 & Olaf & Müller \\
			\hline
			2313 & Jürgen & Paulsen \\
			\hline
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}
\hfill
\begin{minipage}{.45\textwidth}
	\begin{center}
		$P_{Name}(Schueler)$ \\
		\vspace{1em}
		\bgroup
		\setlength{\tabcolsep}{1em}
		\def\arraystretch{1.5}
		\begin{tabular}{|l|}
			\hline
			\rowcolor{tableLightGray} Name \\
			\hline
			Müller \\
			\hline
			Schmidt \\
			\hline
			Lehmann \\
			\hline
			Müller \\
			\hline
			Paulsen \\
			\hline
		\end{tabular}
		\egroup
	\end{center}
\end{minipage}


\subsubsection{DDL, DML \& DCL}
\label{sec:DDLDMLDCL}

Quelle: GeeksforGeeks \cite{DDLDMLDCL}

\begin{enumerate}
	\item DDL - Data Definition Language
	\item DML - Data Manipulation Language
	\item DQL - Data Query Language
	\item DCL - Data Control Language
\end{enumerate}

\begin{center}
	\begin{tikzpicture}[
	item/.style={rectangle,draw,fill=blue!30, inner sep = 10},
	subitem/.style={rectangle,draw,fill=blue!20, inner sep = 8},
	grandchild/.style={grow=down,xshift=1em,anchor=west,
		edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}},
	first/.style={level distance=6ex},
	second/.style={level distance=12ex},
	third/.style={level distance=18ex},
	forth/.style={level distance=24ex},
	level 1/.style={sibling distance=10em}]
	% Parents
	\coordinate
	node[item,anchor=east]{SQL Commands}
	child[grow=down,level distance=2.5ex]
	[edge from parent fork down]
	% Children and grandchildren
	child{node[item] {DDL}
		child[grandchild,first] {node[subitem]{CREATE}}
		child[grandchild,second] {node[subitem]{DROP}}
		child[grandchild,third] {node[subitem] {ALTER}}
		child[grandchild, forth] {node[subitem] {TRUNCATE}}}
	child{node[item] {DML}
		child[grandchild,first] {node[subitem]{INSERT}}
		child[grandchild,second] {node[subitem]{UPDATE}}
		child[grandchild,third] {node[subitem]{DELETE}}}
	child {node[item]{DQL}
		child[grandchild,first] {node[subitem]{SELECT}}}
	child {node[item]{DCL}
		child[grandchild,first] {node[subitem]{GRANT}}
		child[grandchild,second] {node[subitem]{REVOKE}}};
\end{tikzpicture}
\end{center}

\subsubsection{CRUD}
\label{sec:CRUD}

Quelle: sqlshack.com \cite{crud}

\paragraph{C} refers to CREATE aka add, insert. In this operation, it is expected to insert a new record using the SQL insert statement. SQL uses \hl{INSERT INTO} statement to create new records within the table.

\begin{lstlisting}[language=SQL]
	INSERT INTO <tablename> (column1,column2,...) 
	VALUES(value1,value2,...),( value1,value2,...), (value1,value2,...)...
\end{lstlisting}

\begin{lstlisting}[language=SQL]
	INSERT INTO dbo.Demo
	(id, name)
	VALUES
	(2, 'Jayaram'),
	(3, 'Pravitha');
\end{lstlisting}

\paragraph{R} refers to SELECT (data retrieval) operation. The word ‘read’ retrieves data or record-set from a listed table(s). SQL uses the SELECT command to retrieve the data.

\begin{lstlisting}[language=SQL]
	SELECT * FROM <TableName>;
\end{lstlisting}

\paragraph{U} refers to Update operation. Using the Update keyword, SQL brings a change to an existing record(s) of the table. When performing an update, you’ll need to define the target table and the columns that need to update along with the associated values, and you may also need to know which rows need to be updated. In general, you want to limit the number of rows in order to avoid lock escalation and concurrency issues.

\begin{lstlisting}[language=SQL]
	UPDATE <TableName>
	SET Column1=Value1, Column2=Value2,...
	WHERE <Expression>
\end{lstlisting}

\paragraph{D} refers to removing a record from a table. SQL uses the SQL DELETE command to delete the record(s) from the table.

\begin{lstlisting}[language=SQL]
	DELETE FROM <TableName>
	WHERE <Expression>
\end{lstlisting}

\subsubsection{Subqueries}
\label{sec:Subquery}



\subsubsection{Aggregatfunktionen}
\label{sec:Aggregatfunktionen}

\subsubsection{Schnitt-, Vereinigungs- und Differenzmenge}
\label{sec:SchnittVereinigungsDifferenzmenge}

\subsubsection{SQL Injection}
\label{sec:SQLInjection}

